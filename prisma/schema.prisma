// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// USER TYPE ENUM
// Distinguishes between B2C personal users, B2B candidates, and employees
// ========================================
enum UserType {
  PERSONAL  // B2C self-service users (individuals practicing interviews)
  CANDIDATE // B2B users invited by recruiters
  EMPLOYEE  // B2B users from employee hub
}

// ========================================
// IDENTITY VERIFICATION STATUS
// Tracks Brazil KYC verification status
// ========================================
enum IdentityVerificationStatus {
  NOT_STARTED
  PENDING
  VERIFIED
  FAILED
  EXPIRED
}

// ========================================
// USER MODEL
// Synced with Clerk - stores additional user data
// ========================================
model User {
  id                  String    @id @default(uuid()) @db.Uuid
  clerkId             String    @unique @map("clerk_id")
  email               String    @unique
  firstName           String?   @map("first_name")
  lastName            String?   @map("last_name")
  imageUrl            String?   @map("image_url")
  credits             Int       @default(0)
  isActive            Boolean   @default(true) @map("is_active")
  deletedAt           DateTime? @map("deleted_at")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // User Type & Country (B2C Brazil-only for now)
  userType            UserType  @default(PERSONAL) @map("user_type")
  countryCode         String    @default("BR") @map("country_code") @db.VarChar(2) // ISO-3166 alpha-2

  // Localization & Onboarding Metadata
  preferredLanguage     String?   @map("preferred_language") @db.VarChar(10)
  registrationRegion    String?   @map("registration_region") @db.VarChar(10)
  registrationCountry   String?   @map("registration_country") @db.VarChar(2)
  initialIp             String?   @map("initial_ip") @db.VarChar(45)
  onboardingComplete    Boolean   @default(false) @map("onboarding_complete")
  onboardingCompletedAt DateTime? @map("onboarding_completed_at") // Set when required consents are accepted
  
  // Role & Seniority (synced with Clerk publicMetadata)
  currentRole         String?   @map("current_role") @db.VarChar(50)
  currentSeniority    String?   @map("current_seniority") @db.VarChar(30)
  
  // Auth providers used (google, apple, microsoft, linkedin, email)
  authProviders       String[]  @map("auth_providers") @db.VarChar(30)
  lastAuthProvider    String?   @map("last_auth_provider") @db.VarChar(30)

  // Relations
  interviews      Interview[]
  payments        Payment[]
  paymentProviderConnections PaymentProviderConnection[]
  signupRecord    SignupRecord?
  scoreHistory    InterviewScoreHistory[]
  usageLogs       UsageLog[]
  chatSessions    ChatSession[]
  savedCards      SavedCard[]
  resumeDocuments ResumeDocument[]
  creditsWallet   CreditsWallet?
  creditLedger    CreditLedger[]
  transactionalEmails TransactionalEmail[]
  userConsent     UserConsent?
  identityVerifications IdentityVerificationSession[]

  @@index([clerkId])
  @@index([email])
  @@index([isActive])
  @@index([preferredLanguage])
  @@index([registrationRegion])
  @@index([currentRole])
  @@index([onboardingCompletedAt])
  @@index([userType])
  @@index([countryCode])
  @@map("users")
}

// ========================================
// CREDITS WALLET MODEL
// Single source of truth for user's credit balance
// ========================================
model CreditsWallet {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @unique @map("user_id") @db.Uuid
  
  // Current balance (always >= 0)
  balance         Int       @default(0)
  
  // Lifetime stats for analytics
  totalEarned     Int       @default(0) @map("total_earned")
  totalSpent      Int       @default(0) @map("total_spent")
  totalPurchased  Int       @default(0) @map("total_purchased")
  totalGranted    Int       @default(0) @map("total_granted") // Free credits, promos, etc.
  
  // Last activity tracking
  lastCreditAt    DateTime? @map("last_credit_at")  // Last time credits were added
  lastDebitAt     DateTime? @map("last_debit_at")   // Last time credits were spent
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([balance])
  @@map("credits_wallets")
}

// ========================================
// CREDIT LEDGER MODEL
// Immutable audit trail for all credit transactions
// ========================================
model CreditLedger {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @map("user_id") @db.Uuid
  
  // Transaction details
  type            CreditTransactionType
  amount          Int       // Always positive, type determines direction
  balanceAfter    Int       @map("balance_after") // Balance after this transaction
  
  // Reference to related entity (payment, interview, etc.)
  referenceType   String?   @map("reference_type") @db.VarChar(50) // 'payment', 'interview', 'promo', 'refund', 'admin'
  referenceId     String?   @map("reference_id") @db.Uuid
  
  // Human-readable description
  description     String    @db.VarChar(255)
  
  // Additional metadata (promo codes, admin notes, etc.)
  metadata        Json?     @db.JsonB
  
  // Idempotency key to prevent duplicate transactions
  idempotencyKey  String?   @unique @map("idempotency_key") @db.VarChar(255)
  
  // Timestamps (immutable - no updatedAt)
  createdAt       DateTime  @default(now()) @map("created_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt])
  @@index([type])
  @@index([referenceType, referenceId])
  @@index([createdAt])
  @@map("credit_ledger")
}

// ========================================
// SAVED CARD MODEL
// Stores tokenized payment cards for users
// ========================================
model SavedCard {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  
  // Card token from payment processor (not the actual card number)
  token         String    @db.VarChar(255)
  
  // Display info
  lastFour      String    @map("last_four") @db.VarChar(4)
  brand         String    @db.VarChar(20) // visa, mastercard, amex, etc.
  expiryMonth   String    @map("expiry_month") @db.VarChar(2)
  expiryYear    String    @map("expiry_year") @db.VarChar(4)
  holderName    String    @map("holder_name") @db.VarChar(100)
  
  // Status
  isDefault     Boolean   @default(false) @map("is_default")
  isVerified    Boolean   @default(false) @map("is_verified")
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([isDefault])
  @@map("saved_cards")
}

// ========================================
// RESUME SOURCE ENUM
// Distinguishes how the resume was added to repository
// ========================================
enum ResumeSource {
  UPLOAD    // Manually uploaded by user
  LINKEDIN  // Imported from LinkedIn
  GENERATED // Generated from form input
}

// ========================================
// RESUME SCORE PROVIDER ENUM
// Distinguishes which service provided the score
// ========================================
enum ResumeScoreProvider {
  AFFINDA                    // Affinda ATS parser/matcher
  TEXTKERNEL                 // Textkernel parser
  INTERNAL_KEYWORD           // Internal keyword matching
  INTERNAL_INTERVIEW_OUTCOME // Derived from interview performance
}

// ========================================
// RESUME DOCUMENT MODEL
// User's resume repository with version control
// ========================================
model ResumeDocument {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @map("user_id") @db.Uuid
  
  // Source tracking
  source          ResumeSource @default(UPLOAD)
  
  // File data
  fileName        String    @map("file_name") @db.VarChar(255)
  mimeType        String    @map("mime_type") @db.VarChar(100)
  fileSize        Int       @map("file_size")
  base64Data      String    @map("base64_data") @db.Text
  
  // Metadata
  title           String    @db.VarChar(255)
  description     String?   @db.Text
  tags            String[]  @default([])
  
  // LinkedIn-specific metadata (when source = LINKEDIN)
  linkedInProfileUrl String? @map("linkedin_profile_url") @db.VarChar(500)
  
  // Parsed content (populated by parser)
  parsedText      String?   @map("parsed_text") @db.Text
  parsedMetadata  Json?     @map("parsed_metadata") @db.JsonB
  
  // Version control
  version         Int       @default(1)
  parentVersionId String?   @map("parent_version_id") @db.Uuid
  isLatest        Boolean   @default(true) @map("is_latest")
  
  // Quality score (from resume quality service)
  qualityScore    Int?      @map("quality_score")
  
  // Status flags
  isActive        Boolean   @default(true) @map("is_active")
  isPrimary       Boolean   @default(false) @map("is_primary")
  
  // Usage tracking
  lastUsedAt      DateTime? @map("last_used_at")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentVersion   ResumeDocument? @relation("ResumeVersions", fields: [parentVersionId], references: [id])
  childVersions   ResumeDocument[] @relation("ResumeVersions")
  interviews      Interview[] @relation("ResumeInterviews")
  scores          ResumeScore[]
  
  @@index([userId])
  @@index([isPrimary])
  @@index([isActive, isLatest])
  @@index([tags])
  @@index([lastUsedAt])
  @@index([source])
  @@map("resume_documents")
}

// ========================================
// RESUME SCORE MODEL
// Stores ATS-style scores per resume/role combination
// ========================================
model ResumeScore {
  id              String    @id @default(uuid()) @db.Uuid
  resumeId        String    @map("resume_id") @db.Uuid
  
  // Role matching
  roleTitle       String    @map("role_title") @db.VarChar(255)
  
  // Score data
  score           Float     @db.DoublePrecision // 0-100
  provider        ResumeScoreProvider
  breakdown       Json?     @db.JsonB // Provider-specific breakdown
  
  // Caching - don't recompute if recent
  computedAt      DateTime  @default(now()) @map("computed_at")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  // Relations
  resume          ResumeDocument @relation(fields: [resumeId], references: [id], onDelete: Cascade)
  
  @@unique([resumeId, roleTitle, provider])
  @@index([resumeId])
  @@index([roleTitle])
  @@index([provider])
  @@index([score])
  @@map("resume_scores")
}

// ========================================
// BLOCKED PHONE MODEL
// Stores blocked phone numbers for abuse prevention
// ========================================
model BlockedPhone {
  id            String    @id @default(uuid()) @db.Uuid
  phoneNumber   String    @unique @map("phone_number") @db.VarChar(20)
  reason        String    @db.Text
  blockedBy     String    @map("blocked_by") // Admin or system ID
  blockedAt     DateTime  @default(now()) @map("blocked_at")
  
  @@index([phoneNumber])
  @@map("blocked_phones")
}

// ========================================
// SIGNUP RECORD MODEL
// Tracks signup device/IP to prevent free credit abuse
// ========================================
model SignupRecord {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @unique @map("user_id") @db.Uuid
  
  // IP Address tracking
  ipAddress       String?   @map("ip_address")
  
  // Device fingerprint (from FingerprintJS or similar)
  deviceFingerprint String? @map("device_fingerprint")
  
  // Additional device info
  userAgent       String?   @map("user_agent") @db.Text
  
  // Email domain for disposable email detection
  emailDomain     String?   @map("email_domain")
  
  // Whether free credit was granted
  freeCreditGranted Boolean @default(false) @map("free_credit_granted")
  
  // Credit throttling tier: 'full', 'throttled', 'blocked'
  creditTier      String    @default("full") @map("credit_tier")
  
  // Phone verification
  phoneNumber       String?   @map("phone_number") @db.VarChar(20)
  phoneVerified     Boolean   @default(false) @map("phone_verified")
  phoneVerifiedAt   DateTime? @map("phone_verified_at")
  
  captchaCompleted Boolean  @default(false) @map("captcha_completed")
  linkedInId      String?   @map("linkedin_id")
  
  // Behavioral analysis score (0-100)
  behaviorScore   Int       @default(50) @map("behavior_score")
  
  // Fraud flags
  isSuspicious    Boolean   @default(false) @map("is_suspicious")
  suspicionReason String?   @map("suspicion_reason")
  
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ipAddress])
  @@index([deviceFingerprint])
  @@index([emailDomain])
  @@index([freeCreditGranted])
  @@index([creditTier])
  @@index([phoneNumber])
  @@index([phoneVerified])
  @@map("signup_records")
}

// ========================================
// USER CONSENT MODEL
// Tracks legal consent for Terms, Privacy, and Communications
// Audit-ready with timestamps, versions, and metadata
// ========================================
enum ConsentSource {
  FORM   // Custom sign-up form
  OAUTH  // OAuth provider (Google, Apple, Microsoft, LinkedIn)
}

model UserConsent {
  id                    String        @id @default(uuid()) @db.Uuid
  userId                String        @unique @map("user_id") @db.Uuid
  
  // Required consents (must be accepted to use the product)
  termsAcceptedAt       DateTime      @map("terms_accepted_at")
  privacyAcceptedAt     DateTime      @map("privacy_accepted_at")
  
  // Version tracking for re-consent when terms change
  termsVersion          String        @map("terms_version") @db.VarChar(20)
  privacyVersion        String        @map("privacy_version") @db.VarChar(20)
  
  // Communication preferences
  transactionalOptIn    Boolean       @default(true) @map("transactional_opt_in")  // Essential emails (receipts, security)
  marketingOptIn        Boolean       @default(false) @map("marketing_opt_in")     // Optional promotional emails
  marketingOptInAt      DateTime?     @map("marketing_opt_in_at")                  // When marketing was accepted
  marketingVersion      String?       @map("marketing_version") @db.VarChar(20)   // Version of marketing consent text
  
  // Audit metadata for compliance
  ipAddress             String?       @map("ip_address") @db.VarChar(45)
  userAgent             String?       @map("user_agent") @db.Text
  source                ConsentSource @default(FORM)
  
  // Timestamps
  createdAt             DateTime      @default(now()) @map("created_at")
  updatedAt             DateTime      @updatedAt @map("updated_at")
  
  // Relations
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([termsAcceptedAt])
  @@index([privacyAcceptedAt])
  @@index([marketingOptIn])
  @@index([source])
  @@map("user_consents")
}

// ========================================
// INTERVIEW MODEL
// Stores interview sessions and their results
// ========================================
model Interview {
  id              String           @id @default(uuid()) @db.Uuid
  userId          String           @map("user_id") @db.Uuid
  retellCallId    String?          @unique @map("retell_call_id")
  
  // Interview Details
  jobTitle        String           @map("job_title")
  companyName     String           @map("company_name")
  jobDescription  String           @map("job_description") @db.Text
  
  // Role Country (where the user is applying for the job)
  roleCountryCode String?          @map("role_country_code") @db.VarChar(2) // ISO-3166 alpha-2
  
  // Seniority and Language for LLM configuration
  seniority       String?          @db.VarChar(30) // Intern, Junior, Mid, Senior, Staff, Principal, Manager
  language        String?          @db.VarChar(10) // Language code used for the interview
  
  // Multilingual session tracking (for Retell agent switching)
  agentId         String?          @map("agent_id") @db.VarChar(100) // Retell agent ID used
  voiceId         String?          @map("voice_id") @db.VarChar(100) // Voice ID used
  resumeScoreAtSession Int?        @map("resume_score_at_session") // Resume quality score at time of interview
  
  // Resume stored as base64 or file reference
  resumeData      String?          @map("resume_data") @db.Text
  resumeFileName  String?          @map("resume_file_name")
  resumeMimeType  String?          @map("resume_mime_type")
  resumeId        String?          @map("resume_id") @db.Uuid // Reference to ResumeDocument if using saved resume
  
  // Interview Results
  status          InterviewStatus  @default(PENDING)
  score           Float?           @db.DoublePrecision
  
  // Feedback stored as base64 encoded PDF
  feedbackPdf     String?          @map("feedback_pdf") @db.Text
  feedbackText    String?          @map("feedback_text") @db.Text
  
  // Call metrics (from Retell)
  callDuration    Int?             @map("call_duration") // in seconds
  startedAt       DateTime?        @map("started_at")
  endedAt         DateTime?        @map("ended_at")
  
  // Transcript storage for performance chat
  transcript      String?          @db.Text
  
  // Advanced Analytics Fields (populated from Retell call_analysis)
  sentimentScore  Float?           @map("sentiment_score") @db.DoublePrecision // Overall sentiment 0-100
  wpmAverage      Float?           @map("wpm_average") @db.DoublePrecision // Words per minute average
  confidenceTimeline Json?         @map("confidence_timeline") @db.JsonB // Array of {timestamp, value, tone, pace}
  
  // Email Tracking Fields (for post-interview feedback email)
  emailSentAt        DateTime?     @map("email_sent_at")
  emailSendStatus    EmailSendStatus @default(PENDING) @map("email_send_status")
  emailLastError     String?       @map("email_last_error") @db.Text
  emailIdempotencyKey String?      @unique @map("email_idempotency_key") @db.VarChar(255)
  emailMessageId     String?       @map("email_message_id") @db.VarChar(255) // Resend message ID
  
  // Timestamps
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  // Relations
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  resumeDocument  ResumeDocument?  @relation("ResumeInterviews", fields: [resumeId], references: [id])
  metrics         InterviewMetric[]
  scoreHistory    InterviewScoreHistory[]
  transcriptSegments TranscriptSegment[]
  emailLogs       EmailLog[]
  feedbackJsons   FeedbackJson[]
  feedbackPdfs    FeedbackPdf[]
  session         InterviewSession?

  @@index([userId])
  @@index([retellCallId])
  @@index([status])
  @@index([createdAt])
  @@index([jobTitle])
  @@index([companyName])
  @@index([seniority])
  @@index([language])
  @@index([resumeId])
  @@index([emailSendStatus])
  @@index([roleCountryCode])
  @@index([userId, createdAt])
  @@index([userId, endedAt])
  @@map("interviews")
}

// ========================================
// FEEDBACK JSON MODEL
// Stores versioned structured feedback from LLM
// ========================================
model FeedbackJson {
  id              String    @id @default(uuid()) @db.Uuid
  interviewId     String    @map("interview_id") @db.Uuid
  
  // Versioning
  schemaVersion   String    @map("schema_version") @db.VarChar(20)  // e.g., "1.0"
  promptVersion   String    @map("prompt_version") @db.VarChar(50)  // e.g., "v1.0.0"
  model           String    @db.VarChar(100)                        // e.g., "gpt-4-turbo-preview"
  
  // Content
  contentJson     Json      @map("content_json") @db.JsonB          // Full structured feedback
  overallScore    Float     @map("overall_score") @db.DoublePrecision
  
  // Metadata
  generationTimeMs Int?     @map("generation_time_ms")
  tokenCount      Int?      @map("token_count")
  warningCount    Int?      @map("warning_count") @default(0)
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  
  // Relations
  interview       Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  pdfs            FeedbackPdf[]
  
  @@index([interviewId])
  @@index([schemaVersion])
  @@index([createdAt])
  @@map("feedback_jsons")
}

// ========================================
// FEEDBACK PDF MODEL
// Stores generated PDF metadata and references
// ========================================
model FeedbackPdf {
  id              String    @id @default(uuid()) @db.Uuid
  interviewId     String    @map("interview_id") @db.Uuid
  feedbackJsonId  String    @map("feedback_json_id") @db.Uuid
  
  // PDF Metadata
  pageCount       Int       @map("page_count")
  fileSizeBytes   Int       @map("file_size_bytes")
  checksum        String    @db.VarChar(64)                         // SHA-256 hash for integrity
  
  // Storage
  storageKey      String?   @map("storage_key") @db.VarChar(500)    // S3 key or storage reference
  pdfBase64       String?   @map("pdf_base64") @db.Text             // Inline storage (temporary)
  
  // Generation
  locale          String?   @db.VarChar(10)
  includesStudyPlan Boolean @default(true) @map("includes_study_plan")
  includesHighlights Boolean @default(true) @map("includes_highlights")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  
  // Relations
  interview       Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  feedbackJson    FeedbackJson @relation(fields: [feedbackJsonId], references: [id], onDelete: Cascade)
  
  @@index([interviewId])
  @@index([feedbackJsonId])
  @@index([checksum])
  @@index([createdAt])
  @@map("feedback_pdfs")
}

// ========================================
// INTERVIEW METRICS MODEL
// Stores detailed interview performance metrics
// ========================================
model InterviewMetric {
  id            String    @id @default(uuid()) @db.Uuid
  interviewId   String    @map("interview_id") @db.Uuid
  
  // Metric categories
  category      String    // e.g., "communication", "technical", "behavioral"
  metricName    String    @map("metric_name")
  score         Float     @db.DoublePrecision
  maxScore      Float     @default(10) @map("max_score") @db.DoublePrecision
  feedback      String?   @db.Text
  
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  interview     Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@index([interviewId])
  @@index([category])
  @@map("interview_metrics")
}

// ========================================
// TRANSCRIPT SEGMENT MODEL
// Stores timestamped transcript segments for media sync
// ========================================
model TranscriptSegment {
  id            String    @id @default(uuid()) @db.Uuid
  interviewId   String    @map("interview_id") @db.Uuid
  
  // Segment content
  speaker       String    // 'agent' or 'user'
  content       String    @db.Text
  
  // Time markers for audio/video sync (in seconds)
  startTime     Float     @map("start_time") @db.DoublePrecision
  endTime       Float     @map("end_time") @db.DoublePrecision
  
  // Segment-level analytics
  sentimentScore Float?   @map("sentiment_score") @db.DoublePrecision
  
  // Ordering
  segmentIndex  Int       @map("segment_index")
  
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  interview     Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@index([interviewId])
  @@index([startTime])
  @@index([segmentIndex])
  @@map("transcript_segments")
}

// ========================================
// ROLE PERFORMANCE BENCHMARK MODEL
// Stores aggregated performance metrics per role for comparative analysis
// ========================================
model RolePerformanceBenchmark {
  id                  String    @id @default(uuid()) @db.Uuid
  
  // Role identification (normalized job title)
  roleTitle           String    @unique @map("role_title")
  
  // Aggregated metrics
  globalAverageScore  Float     @map("global_average_score") @db.DoublePrecision
  totalInterviews     Int       @map("total_interviews")
  
  // Score distribution for percentile calculation
  scoreDistribution   Json      @map("score_distribution") @db.JsonB // {buckets: [{min, max, count}]}
  
  // Soft skills averages
  avgCommunication    Float?    @map("avg_communication") @db.DoublePrecision
  avgProblemSolving   Float?    @map("avg_problem_solving") @db.DoublePrecision
  avgTechnicalDepth   Float?    @map("avg_technical_depth") @db.DoublePrecision
  avgLeadership       Float?    @map("avg_leadership") @db.DoublePrecision
  avgAdaptability     Float?    @map("avg_adaptability") @db.DoublePrecision
  
  // Metadata
  lastCalculatedAt    DateTime  @map("last_calculated_at") @default(now())
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  @@index([roleTitle])
  @@index([lastCalculatedAt])
  @@map("role_performance_benchmarks")
}

// ========================================
// AI STUDY RECOMMENDATIONS MODEL
// Stores AI-generated learning recommendations per interview
// ========================================
model StudyRecommendation {
  id            String    @id @default(uuid()) @db.Uuid
  interviewId   String    @unique @map("interview_id") @db.Uuid
  
  // Recommendation data
  topics        Json      @db.JsonB // [{topic, priority, reason, resources}]
  weakAreas     Json      @map("weak_areas") @db.JsonB // [{area, score, suggestion}]
  
  // Metadata
  generatedAt   DateTime  @default(now()) @map("generated_at")
  
  @@index([interviewId])
  @@map("study_recommendations")
}

// ========================================
// PAYMENT MODEL
// Stores payment transaction records
// ========================================
model Payment {
  id                  String        @id @default(uuid()) @db.Uuid
  userId              String        @map("user_id") @db.Uuid
  
  // Payment provider (for multi-provider support)
  provider            PaymentProvider @default(MERCADOPAGO)
  
  // MercadoPago identifiers
  mercadoPagoId       String?       @unique @map("mercadopago_id")
  preferenceId        String?       @map("preference_id")
  
  // Generic provider payment ID (for PayPal, Stripe, etc.)
  providerPaymentId   String?       @map("provider_payment_id") @db.VarChar(255)
  
  // Package details
  packageId           String        @map("package_id")
  packageName         String        @map("package_name")
  creditsAmount       Int           @map("credits_amount")
  
  // Payment amounts
  amountUSD           Float         @map("amount_usd") @db.DoublePrecision
  amountBRL           Float         @map("amount_brl") @db.DoublePrecision
  currency            String?       @db.VarChar(3) // ISO 4217 currency code
  exchangeRate        Float?        @map("exchange_rate") @db.DoublePrecision
  
  // Payment status
  status              PaymentStatus @default(PENDING)
  statusDetail        String?       @map("status_detail")
  
  // Webhook idempotency (prevents duplicate processing)
  webhookIdempotencyKey String?     @unique @map("webhook_idempotency_key") @db.VarChar(255)
  webhookProcessedAt    DateTime?   @map("webhook_processed_at")
  
  // Timestamps
  paidAt              DateTime?     @map("paid_at")
  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @updatedAt @map("updated_at")

  // Relations
  user                User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([mercadoPagoId])
  @@index([provider])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

// ========================================
// PAYMENT PROVIDER CONNECTION MODEL
// Stores OAuth tokens for "Log in with PayPal" and similar flows
// Enables seamless one-click checkout for returning customers
// ========================================
model PaymentProviderConnection {
  id                  String          @id @default(uuid()) @db.Uuid
  userId              String          @map("user_id") @db.Uuid
  
  // Provider identification
  provider            PaymentProvider
  providerAccountId   String?         @map("provider_account_id") @db.VarChar(255)
  providerEmail       String?         @map("provider_email") @db.VarChar(255)
  
  // OAuth tokens (encrypted in production)
  accessToken         String?         @map("access_token") @db.Text
  refreshToken        String?         @map("refresh_token") @db.Text
  tokenExpiresAt      DateTime?       @map("token_expires_at")
  
  // Scope/permissions granted
  scopes              String[]        @db.VarChar(100)
  
  // Connection status
  isActive            Boolean         @default(true) @map("is_active")
  lastUsedAt          DateTime?       @map("last_used_at")
  
  // Metadata
  connectedAt         DateTime        @default(now()) @map("connected_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")
  
  // Relations
  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@index([provider])
  @@index([isActive])
  @@map("payment_provider_connections")
}

// ========================================
// INTERVIEW SCORE HISTORY MODEL
// Historical score tracking by role and company for analytics
// ========================================
model InterviewScoreHistory {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  interviewId   String    @map("interview_id") @db.Uuid
  
  // Role and company for filtering/aggregation
  role          String    // Normalized job title/role
  company       String    // Company name
  
  // Scores
  overallScore  Float     @map("overall_score") @db.DoublePrecision
  technicalScore Float?   @map("technical_score") @db.DoublePrecision
  communicationScore Float? @map("communication_score") @db.DoublePrecision
  confidenceScore Float?  @map("confidence_score") @db.DoublePrecision
  
  // Metadata
  callDuration  Int?      @map("call_duration") // in seconds
  
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  interview     Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)

  @@index([userId, role])
  @@index([userId, company])
  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([role])
  @@map("interview_score_history")
}

// ========================================
// USAGE LOG MODEL
// Tracks user activity for analytics, monitoring, and quota tracking
// ========================================
model UsageLog {
  id            String    @id @default(uuid()) @db.Uuid
  userId        String    @map("user_id") @db.Uuid
  
  // Event type: 'interview_started', 'interview_completed', 'credits_purchased', etc.
  eventType     String    @map("event_type")
  
  // Resource type for quota tracking
  resourceType  String?   @map("resource_type") @db.VarChar(50)
  
  // Amount consumed (for quota tracking)
  amount        Int       @default(0)
  
  // Related interview (optional)
  interviewId   String?   @map("interview_id") @db.Uuid
  
  // Description
  description   String?   @db.Text
  
  // Flexible event data
  eventData     Json?     @map("event_data") @db.JsonB
  
  // For quick time-series queries
  timestamp     DateTime  @default(now())
  createdAt     DateTime  @default(now()) @map("created_at")
  
  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([userId, resourceType, createdAt])
  @@index([eventType, timestamp])
  @@index([timestamp])
  @@map("usage_logs")
}

// ========================================
// DISPOSABLE EMAIL DOMAIN MODEL
// Blocklist for temporary/disposable email providers
// ========================================
model DisposableEmailDomain {
  id        String    @id @default(uuid()) @db.Uuid
  domain    String    @unique
  source    String?   // Where this domain was sourced from
  isActive  Boolean   @default(true) @map("is_active")
  addedAt   DateTime  @default(now()) @map("added_at")

  @@index([domain])
  @@index([isActive])
  @@map("disposable_email_domains")
}

// ========================================
// SUBNET TRACKER MODEL
// Tracks signup velocity from IP subnets for abuse detection
// ========================================
model SubnetTracker {
  id            String    @id @default(uuid()) @db.Uuid
  subnet        String    // /24 subnet (e.g., "192.168.1.0/24")
  signupCount   Int       @default(1) @map("signup_count")
  lastSignupAt  DateTime  @default(now()) @map("last_signup_at")
  windowStart   DateTime  @default(now()) @map("window_start")
  
  // Automatic cleanup after 24 hours
  expiresAt     DateTime  @map("expires_at")

  @@unique([subnet, windowStart])
  @@index([subnet])
  @@index([windowStart])
  @@index([expiresAt])
  @@map("subnet_trackers")
}

// ========================================
// PERFORMANCE CHAT SESSION MODEL
// Stores chat history for performance analyst conversations
// ========================================
model ChatSession {
  id          String    @id @default(uuid()) @db.Uuid
  userId      String    @map("user_id") @db.Uuid
  
  // Chat context filters
  roleFilter  String?   @map("role_filter")
  companyFilter String? @map("company_filter")
  
  // Session state
  isActive    Boolean   @default(true) @map("is_active")
  
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages    ChatMessage[]

  @@index([userId])
  @@index([isActive])
  @@map("chat_sessions")
}

// ========================================
// CHAT MESSAGE MODEL
// Individual messages in a chat session
// ========================================
model ChatMessage {
  id          String    @id @default(uuid()) @db.Uuid
  sessionId   String    @map("session_id") @db.Uuid
  
  // Message content
  role        String    // 'user' or 'assistant'
  content     String    @db.Text
  
  // Optional metadata
  metadata    Json?     @db.JsonB
  
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  session     ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
  @@map("chat_messages")
}

// ========================================
// ENUMS
// ========================================

enum InterviewStatus {
  PENDING     // Interview created but not started
  IN_PROGRESS // Interview currently in progress
  COMPLETED   // Interview completed successfully
  FAILED      // Interview failed (technical error)
  CANCELLED   // Interview cancelled by user
}

enum PaymentStatus {
  PENDING     // Payment initiated
  APPROVED    // Payment successful
  REJECTED    // Payment rejected
  CANCELLED   // Payment cancelled
  REFUNDED    // Payment refunded
  IN_PROCESS  // Payment being processed
}

enum PaymentProvider {
  MERCADOPAGO // Mercado Pago (LATAM primary)
  PAYPAL      // PayPal (Global)
  STRIPE      // Stripe (Future)
}

enum CreditTransactionType {
  PURCHASE    // Credits purchased via payment
  GRANT       // Free credits (signup bonus, promo)
  SPEND       // Credits spent on interview
  REFUND      // Credits refunded (payment refund)
  RESTORE     // Credits restored (early quit)
  ADMIN       // Manual adjustment by admin
  PROMO       // Promotional credits
  REFERRAL    // Referral bonus credits
  EXPIRE      // Credits expired (if implementing expiry)
}

enum EmailSendStatus {
  PENDING     // Email not yet sent
  SENDING     // Email currently being sent (in progress)
  SENT        // Email sent successfully
  FAILED      // Email failed to send
  SKIPPED     // Email skipped (user opted out)
}

enum TransactionalEmailType {
  WELCOME                    // Registration confirmation email
  CREDITS_PURCHASE_RECEIPT   // Purchase confirmation with receipt
  PASSWORD_RESET             // Password reset instructions
  INTERVIEW_REMINDER         // Reminder about scheduled/unfinished interview
  LOW_CREDITS_WARNING        // Warning when credits are running low
  INTERVIEW_COMPLETE         // Interview completed summary
}

enum EmailProvider {
  RESEND      // Resend email service
}

enum LeadType {
  DEMO_REQUEST     // B2B demo request
  EARLY_ACCESS     // Early access signup for B2B modules
}

enum LeadSource {
  LANDING_PAGE     // From main landing page
  PLATFORM_SHOWCASE // From platform showcase section
  PRICING_PAGE     // From pricing page
  OTHER            // Other sources
}

// ========================================
// EMAIL LOG MODEL
// Audit trail for all sent emails
// ========================================
model EmailLog {
  id              String          @id @default(uuid()) @db.Uuid
  
  // Reference to interview
  interviewId     String          @map("interview_id") @db.Uuid
  
  // Email details
  toEmail         String          @map("to_email") @db.VarChar(255)
  subject         String          @db.VarChar(500)
  templateType    String          @map("template_type") @db.VarChar(50) // 'feedback', 'welcome', 'automated_feedback'
  
  // Delivery tracking
  status          EmailSendStatus @default(PENDING)
  messageId       String?         @map("message_id") @db.VarChar(255) // Resend message ID
  errorMessage    String?         @map("error_message") @db.Text
  
  // Idempotency
  idempotencyKey  String?         @unique @map("idempotency_key") @db.VarChar(255)
  
  // Metadata
  language        String?         @db.VarChar(10)
  hasAttachment   Boolean         @default(false) @map("has_attachment")
  attachmentSize  Int?            @map("attachment_size") // Size in bytes
  
  // Timestamps
  sentAt          DateTime?       @map("sent_at")
  createdAt       DateTime        @default(now()) @map("created_at")
  
  // Relations
  interview       Interview       @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  
  @@index([interviewId])
  @@index([status])
  @@index([toEmail])
  @@index([templateType])
  @@index([createdAt])
  @@map("email_logs")
}

// ========================================
// TRANSACTIONAL EMAIL MODEL
// Tracks transactional emails (welcome, purchase receipts) with idempotency
// Independent of interviews - for user-level communications
// ========================================
model TransactionalEmail {
  id              String                    @id @default(uuid()) @db.Uuid
  
  // User reference (nullable for system emails)
  userId          String?                   @map("user_id") @db.Uuid
  
  // Email details
  toEmail         String                    @map("to_email") @db.VarChar(255)
  emailType       TransactionalEmailType    @map("email_type")
  
  // Delivery tracking
  status          EmailSendStatus           @default(PENDING)
  provider        EmailProvider             @default(RESEND)
  providerMessageId String?                 @map("provider_message_id") @db.VarChar(255)
  
  // Idempotency - CRITICAL for preventing duplicates
  // Welcome: "welcome:<clerkUserId>"
  // Purchase: "purchase:<provider>:<paymentIdOrOrderId>"
  idempotencyKey  String                    @unique @map("idempotency_key") @db.VarChar(255)
  
  // Payload (sanitized - no sensitive data)
  payloadJson     Json?                     @map("payload_json") @db.JsonB
  
  // Error tracking
  errorJson       Json?                     @map("error_json") @db.JsonB
  retryCount      Int                       @default(0) @map("retry_count")
  
  // Metadata
  language        String?                   @db.VarChar(10)
  
  // Timestamps
  sentAt          DateTime?                 @map("sent_at")
  createdAt       DateTime                  @default(now()) @map("created_at")
  updatedAt       DateTime                  @updatedAt @map("updated_at")
  
  // Relations
  user            User?                     @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([emailType])
  @@index([status])
  @@index([toEmail])
  @@index([createdAt])
  @@map("transactional_emails")
}

// ========================================
// LEAD MODEL
// Captures demo requests and early access signups
// ========================================
model Lead {
  id              String      @id @default(uuid()) @db.Uuid
  
  // Contact Information
  name            String
  email           String
  company         String?
  phone           String?
  
  // Lead Classification
  type            LeadType    @default(EARLY_ACCESS)
  source          LeadSource  @default(LANDING_PAGE)
  
  // B2B Specific Fields
  teamSize        String?     @map("team_size")
  useCase         String?     @map("use_case")
  
  // Module Interest (for early access)
  interestedModules String[]  @default([]) @map("interested_modules") // ['recruiter_platform', 'employee_hub']
  
  // Lead Status
  contacted       Boolean     @default(false)
  contactedAt     DateTime?   @map("contacted_at")
  notes           String?     @db.Text
  
  // Tracking
  ipAddress       String?     @map("ip_address") @db.VarChar(45)
  userAgent       String?     @map("user_agent")
  referrer        String?
  
  // Timestamps
  createdAt       DateTime    @default(now()) @map("created_at")
  updatedAt       DateTime    @updatedAt @map("updated_at")

  @@index([email])
  @@index([type])
  @@index([contacted])
  @@index([createdAt])
  @@map("leads")
}

// ========================================
// IDENTITY VERIFICATION SESSION MODEL
// Brazil KYC verification for Personal (B2C) users
// Provider-agnostic design for future vendor integration
// ========================================
model IdentityVerificationSession {
  id              String                      @id @default(uuid()) @db.Uuid
  userId          String                      @map("user_id") @db.Uuid
  
  // Session Status
  status          IdentityVerificationStatus  @default(NOT_STARTED)
  
  // Provider Information (for future vendor integration)
  provider        String?                     @db.VarChar(50) // 'mock', 'serpro', 'datavalid', etc.
  providerSessionId String?                   @map("provider_session_id") @db.VarChar(255)
  
  // Document Information
  documentType    String?                     @map("document_type") @db.VarChar(20) // 'RG', 'CNH', 'CPF'
  documentNumber  String?                     @map("document_number") @db.VarChar(50) // Encrypted in production
  
  // File Storage Paths (local in dev, S3 in production)
  selfiePath      String?                     @map("selfie_path") @db.VarChar(500)
  documentPath    String?                     @map("document_path") @db.VarChar(500)
  
  // Verification Result
  resultJson      Json?                       @map("result_json") @db.JsonB
  failureReason   String?                     @map("failure_reason") @db.Text
  verifiedAt      DateTime?                   @map("verified_at")
  
  // Consent Tracking (LGPD compliance)
  termsAcceptedAt   DateTime?                 @map("terms_accepted_at")
  biometricConsentAt DateTime?                @map("biometric_consent_at")
  consentIpAddress  String?                   @map("consent_ip_address") @db.VarChar(45)
  
  // Timestamps
  createdAt       DateTime                    @default(now()) @map("created_at")
  updatedAt       DateTime                    @updatedAt @map("updated_at")
  expiresAt       DateTime?                   @map("expires_at")
  
  // Relations
  user            User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([status])
  @@index([provider])
  @@index([createdAt])
  @@map("identity_verification_sessions")
}

// ========================================
// INTERVIEW SESSION MODEL
// Rich metrics logging for interview calls
// Tracks timing, token usage, costs, and quality signals
// ========================================
enum InterviewEndReason {
  COMPLETED           // Normal completion
  USER_HANGUP         // User ended call
  TIME_LIMIT          // Maximum duration reached
  INCOMPATIBILITY     // Resume/job mismatch detected
  TECHNICAL_ERROR     // WebSocket or API error
  SILENCE_TIMEOUT     // User stopped responding
  AGENT_ERROR         // LLM or TTS error
}

model InterviewSession {
  id              String              @id @default(uuid()) @db.Uuid
  interviewId     String              @unique @map("interview_id") @db.Uuid
  
  // Call Identifiers
  retellCallId    String?             @map("retell_call_id") @db.VarChar(100)
  retellAgentId   String?             @map("retell_agent_id") @db.VarChar(100)
  
  // Language & Configuration
  language        String              @db.VarChar(10) // Language code (e.g., 'pt-BR', 'en-US')
  roleTitle       String              @map("role_title") @db.VarChar(200)
  seniority       String?             @db.VarChar(30)
  roleCountry     String?             @map("role_country") @db.VarChar(2) // ISO-3166 alpha-2
  
  // Timing Metrics (all in milliseconds)
  callStartedAt       DateTime?       @map("call_started_at")
  firstAgentUtteranceAt DateTime?     @map("first_agent_utterance_at")
  callEndedAt         DateTime?       @map("call_ended_at")
  
  // Latency Metrics (milliseconds)
  timeToFirstToken    Int?            @map("time_to_first_token") // LLM response latency
  timeToFirstAudio    Int?            @map("time_to_first_audio") // TTS output latency
  avgResponseLatency  Float?          @map("avg_response_latency") @db.DoublePrecision
  
  // Transcript Metrics
  transcriptLength    Int?            @map("transcript_length") // Character count
  totalTurns          Int?            @map("total_turns") // Agent + User turns
  agentTurns          Int?            @map("agent_turns")
  userTurns           Int?            @map("user_turns")
  
  // OpenAI Token Usage (accumulated across all turns)
  promptTokens        Int?            @map("prompt_tokens")
  completionTokens    Int?            @map("completion_tokens")
  totalTokens         Int?            @map("total_tokens")
  estimatedCostUsd    Float?          @map("estimated_cost_usd") @db.DoublePrecision
  
  // Model Information
  llmModel            String?         @map("llm_model") @db.VarChar(100)
  llmProvider         String?         @map("llm_provider") @db.VarChar(50) // 'openai', 'anthropic', etc.
  
  // Call Quality Signals
  endReason           InterviewEndReason? @map("end_reason")
  completionRate      Float?          @map("completion_rate") @db.DoublePrecision // 0-1 (reached closing)
  clarificationTurns  Int?            @map("clarification_turns") // Agent asked to repeat
  silenceCount        Int?            @map("silence_count") // Reminder triggers
  
  // Retell Metadata (from webhook/call details)
  retellDurationSec   Int?            @map("retell_duration_sec")
  retellDisconnectReason String?      @map("retell_disconnect_reason") @db.VarChar(100)
  
  // B2B Fields (future - behind feature flag)
  hasCustomPrompt     Boolean         @default(false) @map("has_custom_prompt")
  recruiterPromptLength Int?          @map("recruiter_prompt_length")
  
  // Timestamps
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")
  
  // Relations
  interview           Interview       @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  
  @@index([interviewId])
  @@index([retellCallId])
  @@index([language])
  @@index([roleTitle])
  @@index([callStartedAt])
  @@index([endReason])
  @@map("interview_sessions")
}

// ========================================
// ANALYTICS CACHE MODEL
// Pre-computed analytics for fast dashboard loading
// Reduces expensive aggregate queries
// ========================================

model AnalyticsCache {
  id              String   @id @default(uuid()) @db.Uuid
  userId          String   @map("user_id") @db.VarChar(255)
  cacheKey        String   @map("cache_key") @db.VarChar(100) // 'dashboard', 'scores_by_role', etc.
  cacheData       Json     @map("cache_data")
  computedAt      DateTime @map("computed_at")
  expiresAt       DateTime @map("expires_at")
  version         Int      @default(1)
  
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  
  @@unique([userId, cacheKey])
  @@index([userId])
  @@index([expiresAt])
  @@index([cacheKey])
  @@map("analytics_cache")
}

// ========================================
// GLOBAL ANALYTICS SNAPSHOT MODEL
// Pre-computed global statistics (percentiles, benchmarks)
// Updated via scheduled job
// ========================================

model GlobalAnalyticsSnapshot {
  id              String   @id @default(uuid()) @db.Uuid
  snapshotType    String   @map("snapshot_type") @db.VarChar(50) // 'percentiles', 'role_benchmarks', etc.
  snapshotData    Json     @map("snapshot_data")
  recordCount     Int      @map("record_count") // How many records were aggregated
  computedAt      DateTime @map("computed_at")
  
  createdAt       DateTime @default(now()) @map("created_at")
  
  @@unique([snapshotType])
  @@index([snapshotType])
  @@index([computedAt])
  @@map("global_analytics_snapshots")
}
